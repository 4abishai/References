- Virtual memory is a fundamental concept in modern computer systems that enables the efficient utilization of physical memory resources. It involves the *separation of logical memory as perceived by users from physical memory*. This separation allows for the provision of a much *larger virtual memory space than the physical memory* available in the system.
### Virtual vs. Physical Memory 

The **virtual address space** of a process represents the logical view of how the process is stored in memory. It starts at a certain logical address (e.g., address 0) and exists in contiguous memory. However, physical memory may be organized in page frames, and the physical page frames assigned to a process may not be contiguous. It's up to the Memory Management Unit (MMU) to map logical pages to physical page frames in memory.

   - **Logical Address Space**: Each process perceives its memory as a *continuous address space*, starting from address 0 and extending to some maximum address. This is the logical view of memory.
   
   - **Physical Address Space**: Physical memory, on the other hand, consists of a *collection of page frames*. These page frames need not be contiguous in physical memory. The **MMU** translates logical addresses generated by the CPU into physical addresses in memory.
   
   - **Page Mapping**: To efficiently manage memory, the MMU maintains a page table that maps logical pages to physical page frames. When a process references a logical address, the *MMU uses the page table to determine the corresponding physical address*.
![[Pasted image 20240402230028.png]]
Overall, virtual memory simplifies programming tasks, enhances system performance by allowing efficient utilization of physical memory resources, and provides a larger address space for programs to work with.

### Virtual address space
In computer memory management, particularly in systems that implement virtual memory, the heap and stack are two key regions that dynamically allocate memory during program execution. These regions are allowed to grow in opposite directions within the virtual address space.
![[Pasted image 20240402230325.png]]
1. **Heap Growth**: 
   - The heap is used for **dynamic memory allocation**, where *memory is requested and released as needed* during program execution.
   - Typically, the *heap grows upward in memory*. This means that as more memory is allocated, it extends towards higher memory addresses.
   - When a program requests memory from the heap (e.g., using `malloc()` in C or `new` operator in C++), the operating system allocates memory from the heap region.
   - If more memory is needed, the heap expands further upward.

2. **Stack Growth**:
   - The stack is used to manage *function call information*, *local variables*, and other data related to function execution.
   - Typically, the *stack grows downward in memory*. This means that as function calls are made, new stack frames are added to lower memory addresses.
   - When a function is called, space is allocated on the stack for its parameters, return address, and local variables.
   - As functions return, their stack frames are deallocated, allowing the stack to shrink back towards higher memory addresses.

3. **Blank Space (Holes) Between Heap and Stack**:
   - The space between the growing heap and the descending stack is typically left unallocated initially. This creates a large blank space or hole in the virtual address space.
   - This blank space is part of the virtual address space but does not correspond to any actual physical memory pages until the heap or stack grows to fill it.
   - Virtual address spaces that include such holes are termed as **sparse address spaces**.
   - Sparse address spaces are beneficial because they allow for efficient memory utilization. *Memory pages are only allocated when needed, as the heap or stack grows into the blank space*.
   - Additionally, these holes can be filled dynamically during program execution, for example, when dynamically linking libraries or shared objects.
### Advantages

Virtual memory allows a program to execute even if it's not entirely loaded into physical memory. This means that only the portions of the program that are currently needed for execution are loaded into memory, while the rest remains on disk. This ability to *execute partially loaded programs* confers several benefits:

   - **Larger Virtual Address Space**: Programs can be designed to utilize a much *larger virtual address space than the physical memory available in the system*. This simplifies programming tasks, as programmers can work with large datasets or complex algorithms without worrying about physical memory limitations.
   
   - **Increased Concurrent Execution**: Since *each program can occupy less physical memory, more programs can be run concurrently*. This leads to higher CPU utilization and throughput, as more tasks can be processed simultaneously without increasing response time or turnaround time.
   
   - **Faster Program Execution**: With *less I/O needed to load or swap user programs* into memory, each program can run faster. This is because only the *necessary portions of the program are loaded into memory when needed*, reducing the time spent on disk operations. *Less time is spent loading unnccessary programs into memory*

### Page sharing

Virtual memory facilitates sharing **files** and **memory** among processes through mechanisms like page sharing. 

- **Speeding up Process Creation**: During process creation, pages can be shared among parent and child processes using the `fork()` system call. When a new process is created with fork(), it initially shares the same memory pages with its parent process This speeds up the process creation process.

- **Shared System Libraries**: System libraries are shared among processes, saving memory as only one copy is loaded into physical memory. Libraries are typically mapped as read-only, ensuring data integrity.

- **Inter-Process Memory Sharing**: Processes can share memory regions directly, facilitating efficient communication and data exchange without copying large amounts of data.

Overall, virtual memory's sharing capabilities improve memory efficiency, inter-process communication, and process creation speed.